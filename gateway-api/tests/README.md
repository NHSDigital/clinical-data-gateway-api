# Gateway API Tests

This directory contains the test suite for the gateway API.

## Test Structure

- `test_main.py` - Unit tests for the Flask application endpoints (fast, using test client)
- `test_consumer_contract.py` - Consumer contract tests using Pact - defines API expectations and builds pact contract file for provider contract tests
- `test_provider_contract.py` - Provider integration tests using pact contract file from contract tests against the real Flask app to verify the expected contract is met

## Running Tests

### Install Dependencies

```bash
cd gateway-api
poetry install --extras dev
```

### Run All Tests (with Verbose Output)

```bash
poetry run pytest -v
```

### Run Specific Test Types

```bash
# Run only unit tests
poetry run pytest tests/test_main.py -v

# Run only consumer contract tests
poetry run pytest tests/test_consumer_contract.py -v

# Run only provider contract tests
poetry run pytest tests/test_provider_contract.py -v
```

## Test Types

### Unit Tests (`test_main.py`)

Fast tests using Flask's test client without spinning up a server.

### Contract Testing with Pact

Contract testing ensures that the consumer's expectations match the provider's implementation without requiring both systems to be tested together.

**How it works:**

1. **Consumer Tests** (`test_consumer_contract.py`):
   - Define what the consumer EXPECTS from the API
   - Test against a **mock Pact server** (not the real Flask app)
   - The mock server responds based on the defined expectations
   - Generates a pact contract file (`GatewayAPIConsumer-GatewayAPIProvider.json`) with all interactions
   - **Key point:** These tests don't call the real Flask app

2. **Provider Integration Tests** (`test_provider_contract.py`):
   - Spin up the **actual Flask application** on a dynamic port
   - Read the pact contract file generated by consumer tests
   - Verify that the real API implementation satisfies the consumer's expectations
   - **Key point:** This is where the real Flask app gets tested

**The Flow:**

```text
Consumer Test → Mock Pact Server → Contract File (JSON)
                                         ↓
                                 Provider Test ← Real Flask App
```

**Why this approach?**

- Consumer and provider can be developed/tested independently
- Contract file serves as the "agreement" between them
- Changes to the contract are visible in version control
- Catches integration issues early without needing both systems running

### Contract Testing Workflow

**Important:** When modifying consumer expectations, consumer tests must run before provider tests to regenerate the contract file. Since the pact file is committed to version control, provider tests can typically run independently using the existing contract file.

## Pact Files

Consumer tests generate the pact contract files in `tests/pacts/` (e.g., `GatewayAPIConsumer-GatewayAPIProvider.json`).

**Key points:**

- The pact contract file represents the contract between the consumer and provider
- As this file is committed you can track contract changes through git diffs
- The `pact.write_file()` call merges interactions (updates existing or adds new ones)
- Interactions with the same description get replaced; different descriptions get added
