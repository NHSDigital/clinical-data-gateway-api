# Gateway API Tests

This directory contains the unit and contract test suites for the gateway API.

## Test Structure

```text
tests/
├── conftest.py                          # Shared pytest fixtures
├── unit/                                # Unit tests
│   └── test_main.py                    # Flask endpoint unit tests
└── contract/                            # Contract tests (Pact)
    ├── conftest_pact.py                # Pact-specific fixtures
    ├── test_consumer_contract.py       # Consumer contract definitions
    ├── test_provider_contract.py       # Provider contract verification
    └── pacts/                          # Generated pact files
        └── GatewayAPIConsumer-GatewayAPIProvider.json
```

## Running Tests

### Install Dependencies (if not using dev container)

Dev container users can skip this - dependencies are pre-installed during container build.

```bash
cd gateway-api
poetry install --with dev
```

### Run All Tests (with Verbose Output)

```bash
poetry run pytest -v
```

### Run Specific Test Types

```bash
# Run only unit tests
poetry run pytest tests/unit/ -v

# Run only contract tests
poetry run pytest tests/contract/ -v

# Run specific test file
poetry run pytest tests/unit/test_main.py -v
poetry run pytest tests/contract/test_consumer_contract.py -v
poetry run pytest tests/contract/test_provider_contract.py -v
```

## Test Types

### Unit Tests (`unit/`)

Fast tests using Flask's test client without spinning up a server. Located in `tests/unit/`.

### Contract Testing with Pact

Contract testing ensures that the consumer's expectations match the provider's implementation without requiring both systems to be tested together.

**How it works:**

1. **Consumer Tests** (`test_consumer_contract.py`):
   - Define what the consumer EXPECTS from the API
   - Test against a **mock Pact server** (not the real Flask app)
   - The mock server responds based on the defined expectations
   - Generates a pact contract file (`GatewayAPIConsumer-GatewayAPIProvider.json`) with all interactions
   - **Key point:** These tests don't call the real Flask app

2. **Provider Integration Tests** (`test_provider_contract.py`):
   - Spin up the **actual Flask application** on a dynamic port
   - Read the pact contract file generated by consumer tests
   - Verify that the real API implementation satisfies the consumer's expectations
   - **Key point:** This is where the real Flask app gets tested

**The Flow:**

```text
Consumer Test → Mock Pact Server → Contract File (JSON)
                                         ↓
                                 Provider Test ← Real Flask App
```

**Why this approach?**

- Consumer and provider can be developed/tested independently
- Contract file serves as the "agreement" between them
- Changes to the contract are visible in version control
- Catches integration issues early without needing both systems running

### Contract Testing Workflow

**Important:** When modifying consumer expectations, consumer tests must run before provider tests to regenerate the contract file. Since the pact file is committed to version control, provider tests can typically run independently using the existing contract file.

## Pact Files

Consumer tests generate the pact contract files in `tests/contract/pacts/` (e.g., `GatewayAPIConsumer-GatewayAPIProvider.json`).

**Key points:**

- The pact contract file represents the contract between the consumer and provider
- As this file is committed you can track contract changes through git diffs
- The `pact.write_file()` call merges interactions (updates existing or adds new ones)
- Interactions with the same description get replaced; different descriptions get added
