# Gateway API Tests

This directory contains the test suite for the gateway API.

## Test Structure

- `test_main.py` - Unit tests for the Flask application endpoints (fast, using test client)
- `test_consumer_contract.py` - Consumer contract tests using Pact - defines API expectations and builds Pact file for provider contract tests
- `test_provider_contract.py` - Provider integration tests using Pact file from contract tests against a the real Flask app to verify expected contracts is met

## Running Tests

### Install Dependencies

```bash
cd gateway-api
poetry install --extras dev
```

### Run All Tests

```bash
poetry run pytest
```

### Run Specific Test Types

```bash
# Run only unit tests
poetry run pytest tests/test_main.py

# Run only consumer contract tests
poetry run pytest tests/test_consumer_contract.py

# Run only provider contract tests
poetry run pytest tests/test_provider_contract.py
```

### Run with Verbose Output

```bash
poetry run pytest -v
```

### Run with Coverage

```bash
poetry run pytest --cov=gateway_api --cov-report=html
```

## Test Types

### Unit Tests (`test_main.py`)

Fast tests using Flask's test client without spinning up a server. Run these frequently during development.

### Contract Testing with Pact

Contract testing ensures that the consumer's expectations match the provider's implementation without requiring both systems to be tested together.

**How it works:**

1. **Consumer Tests** (`test_consumer_contract.py`):
   - Define what the consumer EXPECTS from the API
   - Test against a **mock Pact server** (not the real Flask app)
   - The mock server responds based on the defined expectations
   - Generates a contract file (`GatewayAPIConsumer-GatewayAPIProvider.json`) with all interactions
   - **Key point:** These tests don't call the real Flask app

2. **Provider Integration Tests** (`test_provider_contract.py`):
   - Spin up the **actual Flask application** on a dynamic port
   - Read the contract file generated by consumer tests
   - Verify that the real API implementation satisfies the consumer's expectations
   - Slower than unit tests - consider running in CI/CD rather than locally for every change
   - **Key point:** This is where the real Flask app gets tested

**The Flow:**

```text
Consumer Test → Mock Pact Server → Contract File (JSON)
                                         ↓
                                 Provider Test ← Real Flask App
```

**Why this approach?**

- Consumer and provider can be developed/tested independently
- Contract file serves as the "agreement" between them
- Changes to the contract are visible in version control
- Catches integration issues early without needing both systems running

### Contract Testing Workflow

**Important:** Consumer tests must run before provider tests because the consumer tests generate the contract file that provider tests verify against.

```bash
# Step 1: Run consumer tests to generate contracts
poetry run pytest tests/test_consumer_contract.py

# Step 2: Verify provider honors the contracts
poetry run pytest tests/test_provider_contract.py
```

## Pact Files

Consumer tests generate pact files in `tests/pacts/` (e.g., `GatewayAPIConsumer-GatewayAPIProvider.json`).

**Key points:**

- The pact file represents the contract between the consumer and provider
- As this file is committed you can track contract changes through git diffs
- The `pact.write_file()` call merges interactions (updates existing or adds new ones)
- Interactions with the same description get replaced; different descriptions get added
