# Gateway API Tests

This directory contains the unit and contract test suites for the gateway API.

## Test Structure

```text
tests/
├── conftest.py                          # Shared pytest fixtures (includes provider_url)
├── unit/                                # Unit tests
│   └── test_main.py                    # Flask endpoint unit tests
├── contract/                            # Contract tests (Pact)
│   ├── test_consumer_contract.py       # Consumer contract definitions
│   ├── test_provider_contract.py       # Provider contract verification
│   └── pacts/                          # Generated pact files
│       └── GatewayAPIConsumer-GatewayAPIProvider.json
└── schema/                              # Schema validation tests
    └── test_openapi_schema.py          # Schemathesis property-based tests
```

## Running Tests

### Install Dependencies (if not using Dev container)

Dev container users can skip this - dependencies are pre-installed during container build.

```bash
cd gateway-api
poetry install --with dev
```

### Run All Tests (with Verbose Output)

```bash
poetry run pytest -v
```

### Run Specific Test Types

```bash
# Run only unit tests
poetry run pytest tests/unit/ -v

# Run only contract tests
poetry run pytest tests/contract/ -v

# Run only schema validation tests
poetry run pytest tests/schema/ -v
```

## Test Types

### Unit Tests (`unit/`)

Fast tests using Flask's test client without spinning up a server. Located in `tests/unit/`.

### Schema Validation Tests (`schema/`)

Property-based API schema validation tests using Schemathesis. These tests automatically generate test cases from the OpenAPI specification (`openapi.yaml`) and validate that the API implementation matches the schema.

**How it works:**

- Loads the OpenAPI schema from `openapi.yaml`
- Uses the `provider_url` fixture to test against the running Flask app
- Automatically generates test cases including:
  - Valid inputs
  - Edge cases
  - Boundary values
  - Invalid inputs
- Validates that responses match the schema definitions

### Contract Testing with Pact

Contract testing ensures that the consumer's expectations match the provider's implementation without requiring both systems to be tested together.

**How it works:**

1. **Consumer Tests** (`test_consumer_contract.py`):
   - Define what the consumer EXPECTS from the API
   - Test against a **mock Pact server** (not the real Flask app)
   - The mock server responds based on the defined expectations
   - Generates a pact contract file (`GatewayAPIConsumer-GatewayAPIProvider.json`) with all interactions
   - **Key point:** These tests don't call the real Flask app

2. **Provider Integration Tests** (`test_provider_contract.py`):
   - Spin up the **actual Flask application** on a dynamic port
   - Read the pact contract file generated by consumer tests
   - Verify that the real API implementation satisfies the consumer's expectations
   - **Key point:** This is where the real Flask app gets tested

**The Flow:**

```text
Consumer Test → Mock Pact Server → Contract File (JSON)
                                         ↓
                                 Provider Test ← Real Flask App
```

**Why this approach as opposed to a unit test that has an expected response object to match against?**

- **Explicit contract documentation** - The pact file is a versioned artifact that documents the API contract
- **Contract evolution tracking** - Because of the above - Git diffs will show exactly how API contracts change over time
- **Consumer-driven development** - Consumers define their needs; providers verify they meet them
- **Independent testing** - Consumer and provider can be developed and tested separately without both running
- **Prevents breaking changes** - Provider tests fail if changes break existing consumer expectations
- **Language/framework agnostic** - Contract files can be shared between different repos and tech stacks

### Contract Testing Workflow

**Important:** When modifying consumer expectations, consumer tests must run before provider tests to regenerate the contract file. Since the pact file is committed to version control, provider tests can typically run independently using the existing contract file.

## Pact Files

Consumer tests generate the pact contract files in `tests/contract/pacts/` (e.g., `GatewayAPIConsumer-GatewayAPIProvider.json`).

**Key points:**

- The pact contract file represents the contract between the consumer and provider
- As this file is committed you can track contract changes through git diffs
- The `pact.write_file()` call merges interactions (updates existing or adds new ones)
- Interactions with the same description get replaced; different descriptions get added

## Shared Fixtures

The `provider_url` fixture in `tests/conftest.py` is shared across test types (contract, schema, etc.). It:

- Spins up the Flask app in a separate thread on a dynamically assigned free port to avoid conflicts
- Returns the URL (e.g., `http://localhost:12345`)
